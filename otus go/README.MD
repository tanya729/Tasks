# OTUS-golang 10.2019

* [hw-1](#hw-1)
* [hw-3](#hw-3)
* [hw-4](#hw-4)
* [hw-6](#hw-6)
* [hw-8](#hw-8)
* [hw-10](#hw-10)
* [hw-12](#hw-12)
* [hw-13](#hw-13)
* [hw-15](#hw-15)
* [hw-19](#hw-19)  
* [hw-21](#hw-21)
* [hw-22](#hw-22)
* [hw-25](#hw-25)
* [hw-28](#hw-28)
* [hw-29](#hw-29)
* [hw-30](#hw-30)

## [hw-1](#hw-1)
Hello now()  
Завести Go репозиторий на GitHub, написать программу печатающую текущее время / точное время с использованием библиотеки NTP.  
Программа должна корректно обрабатывать ошибки библиотеки: распечатывать их в STDERR и возвращать ненулевой код выхода.

## [hw-3](#hw-3)
Распаковка строки
Создать Go функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы / руны, например:  
* "a4bc2d5e" => "aaaabccddddde"  
* "abcd" => "abcd"  
* "45" => "" (некорректная строка)  
Дополнительное задание: поддержка escape - последовательности  
* `qwe\4\5` => `qwe45` (*)   
* `qwe\45` => `qwe44444` (*)  
* `qwe\\5` => `qwe\\\\\` (*)  

## [hw-4](#hw-4)
Частотный анализ  
Цель: Напиcать функцию, принимающую на вход строку с текстом и возвращающую слайс с 10 самыми частовстречающимеся в тексте словами.  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать функцию вида Top10(string) ([]string)  
При необходимости выделить вспомогательные функции  
Написать unit-тесты на функцию  

Пояснения  

Если есть более 10 самых частотых слов (например 15 разных слов встречаются ровно 133 раза, остальные < 100), можно вернуть любые 10 из самых частотных.  

Словоформы не учитываем. "нога", "ногу", "ноги" - это разные слова.  
Слово с большой и маленькой буквы можно считать за разные слова. "Нога" и "нога" - это разные слова.  
Знаки препиания можно считать "буквами" слова или отдельными словами. "-" (тире) - это отдельное слово. "нога," и "нога" - это разные слова.  

Пример: "cat and dog one dog two cats and one man". "dog", "one", "and" - встречаются два раза, это топ-3.  

Задание со звездочкой (*): учитывать большие/маленьгие буквы и знаки препинания. "Нога" и "нога" - это одинаковые слова, "нога," и "нога" - это одинаковые слова, "—" (тире) - это не слово.  

## [hw-6](#hw-6)
Двусвязный список  
Цель: Реализовать двусвязный список: https://en.wikipedia.org/wiki/Doubly_linked_list​  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать типы List и Item (см. ниже) и методы у них.  
Написать unit-тесты проверяющие работу всех методов.  

Ожидаемые типы (псевдокод):  
​
```
List // тип контейнер
Len() // длинна списка
First() // первый Item
Last() // последний Item
PushFront(v interface{}) // добавить значение в начало
PushBack(v interface{}) // добавить значение в конец
Remove(i Item) // удалить элемент
​
Item // элемент списка
Value() interface{} // возвращает значение
Next() *Item // следующий Item
Prev() *Item // предыдущий
```  

## [hw-8](#hw-8)
Параллельное исполнение  
Цель: Написать функцию для параллельного выполнения N заданий (т.е. в N параллельных горутинах). Функция должна останавливать свою работу если произошло M ошибок Сигнатура функции: Run(task []func()error, N int, M int) error Учесть что задания могут выполняться разное время Длинна списка задач L = len(tasks) может быть больше или меньше N.  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать функцию вида Run(task []func()error, N int, M int) error  
При необходимости выделить вспомогательные функции  
Написать unit-тесты на функцию, проверяющие, что  
* если задачи работаю без ошибок, то выполняются все N  
* если в первых M задачах происходят ошибки, то всего выполнится не более N+M задач  

## [hw-10](#hw-10)
Копирование файлов  
Цель: Реализовать утилиту копирования файлов Утилита должна принимать следующие аргументы * файл источник (From) * файл копия (To) * Отступ в источнике (Offset), по умолчанию - 0 * Количество копируемых байт (Limit), по умолчанию - весь файл из From Выводить в консоль прогресс копирования в %, например с помощью github.com/cheggaaa/pb Программа может НЕ обрабатывать файлы, у которых не известна длинна (например /dev/urandom).  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать функцию вида Copy(from string, to string, limit int, offset int) error  
Написать unit-тесты на функцию Copy  
Реализовать функцию main, анализирующую параметры командной строки и вызывающую Copy  
Проверить установку и работу утилиты руками  

## [hw-12](#hw12)
Утилита envdir  
Цель: Реализовать утилиту envdir на Go. Эта утилита позволяет запускать программы получая переменные   окружения из определенной директории. См man envdir Пример go-envdir /path/to/evndir command arg1 arg2  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать функцию вида ReadDir(dir string) (map[string]string, error), которая сканирует указанный каталог и возвращает все переменные окружения, определенные в нем.  
Реализовать функцию вида RunCmd(cmd []string, env map[string]string) int , которая запускает программу с аргументами (cmd) c переопределнным окружением.  
Реализовать функцию main, анализирующую аргументы командной строки и вызывающую ReadDir и RunCmd  

## [hw-13](#hw13)
“Заготовка” для микросервиса “Календарь”  
Цель: В результате выполнения ДЗ должен получиться базовый скелет микросервиса, который будет развиваться в дальнейших ДЗ. В данном задании тренируются навыки: - декомпозиции предметной области; - построения элементарной архитектуры проекта.  
Завести в репозитории отдельную директорию для проекта "Календарь" с отдельным go.mod.  

Создать интерфейс хранилища событий, состоящий из методов для работы с ним:  
- добавление событий в хранилище  
- удаление событий из хранилища  
- изменение событий в хранилище  
- листинг событий  
- пр. на усмотрение студента  
Создать объекты ошибок (error sentinels) соответствующие бизнес ошибкам, например ErrDateBusy - данное время уже занято другим событием.  
Создать структуру, реализующую интерфейс выше логикой хранения событий в памяти (т.е. просто складывать объекты в мапы/слайсы).  
Реализовать unit-тесты проверяющие работу хранилища (в частности ошибки).  
Создать структуру календаря, использующую в себе хранилище. Календарь конструируется в main (в последствии он превратится в GRPC/HTTP-листенер).  

На данном этапе не нужно (всё это будет позже):  
- Делать HTTP, GRPC и пр. интерфейсы к микросервису  
- Писать .proto-файлы  
- Использовать СУБД  
  
Проект должен следовать:  
- https://github.com/golang-standards/project-layout  
- https://golang.org/doc/effective_go.html#package-names  
- https://rakyll.org/style-packages/  

Архитектуры, откуда можно почерпнуть полезное (но необязательно):  
- https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1#.epus9ggex  
- пакетно-ориентированный дизайн (package-oriented design)  
- чистая архитектура (clean architecture)  
  
Важно понять, что в Go нет серебряной пули по архитектуре.  
Понятия выше могут дать полезные концепции, но не стоит слепо следовать им.  

## [hw-15](#hw-15)
(Folder: `hw13`)  
Конфигурирование микросервиса  
Цель: Дополнить "каркас" микросервиса логикой считывания конфига из файла с последующим созданием логгеров с указанными уровнями детализации.  
Необходимо доработать код сервиса "Календарь" из предыдущего задания, добавив в него:  

* Обработку аргументов командной строки  
* Чтение файла конфигурации (параметр --config в командной строке)  
* Создание логгеров и настройка уровня логирования  
* Создание и запуск hello-world web-сервера  

Параметры, передаваемые через аргументы командной строки:  
* --config - путь к конфигу  

Параметры, которые должны быть в конфиге:  
* http - ip и port на котором должен слушать web-сервер  
* log_file - путь к файлу логов  
* log_level - уровень логирования (error / warn / info / debug)  

## [hw-19](#hw-19)  
Telnet  
Цель: Реализовать примитивный telnet клиент:  
Примеры вызовов:  

go-telnet --timeout=10s host port  
go-telnet mysite.ru 8080  
go-telnet --timeout=3s 1.1.1.1 123  

Программа должна подключаться к указанному хосту (ip или доменное имя) и порту по протоколу TCP  
После подключения STDIN программы должен записываться в сокет, а данные полученные и сокета должны выводиться в STDOUT  
  
Опционально в программу можно передать таймаут на подключение к серверу (через аргумент --timeout, по умолчанию 10s)  
Завести в репозитории отдельный пакет (модуль) для этого ДЗ  
Реализовать программу, при необходимости выделив вспомогательные функции  

## [hw-21](#hw-21)
(Folder: `hw13`)  
GRPC сервис  
Цель: Создать GRPC API для сервиса календаря Тех. задание: https://github.com/OtusTeam/Go/blob/master/project-calendar.md Цель данного занятия: отработка навыков работы с GRPC, построение современного API.  
Создать отдельную директорию для Protobuf спек.  
Создать Protobuf спеки с описанием всех методов API, их объектов запросов и ответов.  
Т.к. объект Event будет использоваться во многих ответах разумно выделить его в отдельный message.  
Создать отдельный директорию для кода GRPC сервера  
Сгенерировать код GRPC сервера на основе Protobuf спек (скрипт генерации сохранить в репозиторий).  
Написать код, связывающий GRPC сервер с методами доменной области.  

## [hw-22](#hw-22)
(Folder: `hw13`)  
Работа с базами данных  
Цель: Обеспечить сохранение событий календаря в СУБД Тех. задание: https://github.com/OtusTeam/Go/blob/master/project-calendar.md Цель данного занятия: отработка навыков работы СУБД, SQL, пакетами database/sql и github.com/jmoiron/sqlx  
Установить базу данных (например postgres) локально (или сразу в Docker, если знаете как)  
Создать базу данных и пользователей для проекта календарь  
Создать схему данных (таблицы, индексы) в виде отдельного SQL файла и сохранить его в репозиторий  
В проекте календарь создать отдельный пакет, отвечающий за сохранение моделей в СУБД  
Настройки подключения к СУБД вынести в конфиг проекта  
Изменить код приложения так, что бы обеспечить сохранение событий в СУБД  

## [hw-25](#hw-25)
(Folder: `hw13`)  
Работа с очередями  
Цель: Реализовать "напоминания" о событиях с помощью RabbitMQ. Тех. задание: https://github.com/OtusTeam/Go/blob/master/project-calendar.md Цель данного занятия: отработка навыков работы с RabbitMQ и очередями вообще.  
Установить локально очередь сообщений RabbitMQ (можно сразу в Docker если знаете как)  
Создать процесс (scheduler), который периодически сканирует основную базу данных, выбирая события о которых нужно напомнить.  
При запуске процесс должен подключаться к RabbitMQ и создавать все необходимые структуры (топики) в ней.  
Процесс должен выбирать сообытия для которых следует отправить уведомление, сериализовать их (например в JSON) и складывать в очередь.  
Создать процесс (sender), который читает сообщения из очереди и шлет уведомления.  
Непосредственно отправку делать не нужно - можно просто выводить сообщения в STDOUT. 

## [hw-25](#hw-25)
(Folder: `hw13`)  
Доработка сервиса  
Цель: Данное ДЗ посвящено доработки кода. Новые навыки не отрабатываются. Важно довести проект до рабочего состояния, разделив его на отдельные сервисы.  
В результате компиляции проекта должно получаться 3 отдельных исполняемых файла (по одному на микросервис).  
Пример разбиения сервисов  
- API
- Рассыльщик
- Планировщик

Каждый из сервисов должен принимать путь файлу конфигурации:  

./calendar_api --config=/path/to/config.yaml  
./calendar_scheduler --config=/path/to/config.yaml  
./calendar_sender --config=/path/to/config.yaml

## [hw-28](#hw-28)
(Folder: `hw13`)  
Докеризация сервиса  
Цель: Цель домашнего задания: запустить все компоненты проекта в Docker Отрабатываются навыки работы с Docker и docker-compose  
Создать Dockerfile для каждого из микросервисов (api, scheduler, sender)  
Собрать образы и проверить их локальный запуск  
Создать docker-compose файл, который запускает PostgreSQL, RabbitMQ и все микросервисы вместе.  
Для PostgreSQL и RabbitMQ использовать официальные образы из dockerhub.  
Так же в docker-compose должен запускаться one-shot скрипт который применяет SQL миграции, создавая структуру СУБД.  
Для контейнера с API необходимо пробросить (expose) порт 8888 на хост-машину.   

## [hw-29](#hw-29)
(Folder: `hw13`)  
Интеграционное тестирование  
Цель: Цель данного домашнего задания: научиться писать интеграционные тесты к web-сервисам В данном ДЗ изучается BDD, язык Gherkin, отрабатываются навыки работы с BDD библиотекой github.com/DATA-DOG/godog И еще раз с docker-compose =)  
Создать отдельный пакет для интеграционных тестов  
Описать все бизнес-сценарии на языке Gherkin в *.feature файлах.  
Реализовать все шаги сценариев с использованием библиотеки Godog  
При этом шаги могут рассчитывать на то что запущены в docker-compose и знают hostname:port все сервисов.  
Создать docker-compose файл, поднимающий все сервисы проекта + контейнер с интеграционными тестами  
В Makefile добавить команду test, которая будет запускать интеграционные тесты (см -https://docs.docker.com/compose/reference/up/ -exit-code-from)      

## [hw-30](#hw-30)
(Folder: `hw13`)  
Мониторинг сервиса  
Обеспечить простейший мониторинг проекта с помощью prometheus  
Prometheus запустить в docker контейнере рядом с остальными сервисами.  
Для API сервиса необходимо измерять:  
* Requests per second  
* Latency  
* Коды ошибок  
* Все это в разделении по методам (использовать отдельный тэг prometheus для каждого метода API)  
Для баз данных:  
* Количество записей в таблице events (данные брать из pg_stat_user_tables)  
* Стандартные метрики базы: Transactions per second, количество подключений (использовать готовый exporter)  